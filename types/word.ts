/**
 * Core Word type definitions for the application.
 * This is the single source of truth for all word-related types.
 */

/**
 * The main Word data structure used throughout the application.
 * Represents a word entry with all its metadata, linguistic information,
 * and geographical data.
 */
export interface WordData {
  word: string;
  language: string;
  family: string;
  category: string;
  definition: string;
  literal: string;
  usage_notes: string;
  english_approx: string;
  location: string;
  lat: number;
  lng: number;
  source: string;
  pronunciation: string;
  phonetic: string;
  embedding: number[];
  embeddingHash: string;
}

/**
 * Extended Word type that includes optional searchable text field.
 * Used in semantic search functionality.
 */
export interface WordWithEmbedding extends WordData {
  searchableText?: string;
}

/**
 * Complete Word type without embedding data.
 * Used in words.json which stores all word metadata except embeddings.
 * Embeddings are stored separately in words-with-embeddings.json.
 */
export type WordDataWithoutEmbedding = Omit<WordData, 'embedding' | 'embeddingHash'>;

/**
 * Partial Word type for scripts that don't require all fields.
 * Used when creating or updating words where not all fields are available.
 */
export interface PartialWordData {
  word: string;
  language: string;
  source: string;
  family?: string;
  category?: string;
  definition?: string;
  literal?: string;
  usage_notes?: string;
  english_approx?: string;
  phonetic?: string;
  pronunciation?: string;
  embedding?: number[];
  embeddingHash?: string;
  location?: string;
  lat?: number;
  lng?: number;
  [key: string]: any;
}

/**
 * Metadata generated by Braintrust for word enrichment.
 * Used in scripts that generate additional word information.
 */
export interface BraintrustMetadata {
  word: string;
  language: string;
  family: string;
  category: string;
  definition: string;
  literal: string;
  usage_notes: string;
  english_approx: string;
  phonetic: string;
  location: string;
  lat: number;
  lng: number;
}
